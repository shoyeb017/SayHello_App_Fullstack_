/// Online Session Provider - State management for course sessions
/// Handles session loading, creation, updates, and deletion

import 'package:flutter/material.dart';
import '../models/course_session.dart';
import '../data/online_session_data.dart';

class OnlineSessionProvider extends ChangeNotifier {
  final OnlineSessionRepository _sessionRepository = OnlineSessionRepository();

  // Session state
  List<CourseSession> _sessions = [];
  Map<String, int> _sessionStats = {};
  CourseSession? _currentSession;

  // Loading states
  bool _isLoading = false;
  bool _isCreating = false;
  bool _isUpdating = false;
  bool _isDeleting = false;

  // Error state
  String? _error;

  // Getters
  List<CourseSession> get sessions => _sessions;
  Map<String, int> get sessionStats => _sessionStats;
  CourseSession? get currentSession => _currentSession;
  bool get isLoading => _isLoading;
  bool get isCreating => _isCreating;
  bool get isUpdating => _isUpdating;
  bool get isDeleting => _isDeleting;
  String? get error => _error;
  bool get hasError => _error != null;

  // Filter sessions by status
  List<CourseSession> get upcomingSessions =>
      _sessions.where((s) => s.isUpcoming).toList();

  List<CourseSession> get completedSessions =>
      _sessions.where((s) => s.isCompleted).toList();

  // =============================
  // SESSION LOADING
  // =============================

  /// Load all sessions for a course
  Future<void> loadSessions(String courseId) async {
    _setLoading(true);
    _clearError();

    try {
      // Test database schema first
      await _sessionRepository.testDatabaseSchema();

      _sessions = await _sessionRepository.getSessionsByCourse(courseId);
      await _loadSessionStats(courseId);
      notifyListeners();
    } catch (e) {
      _setError('Failed to load sessions: $e');
    } finally {
      _setLoading(false);
    }
  }

  /// Load session statistics
  Future<void> _loadSessionStats(String courseId) async {
    try {
      _sessionStats = await _sessionRepository.getSessionStats(courseId);
    } catch (e) {
      print('Error loading session stats: $e');
      _sessionStats = {'total': 0, 'completed': 0, 'upcoming': 0};
    }
  }

  /// Refresh sessions data
  Future<void> refreshSessions(String courseId) async {
    await loadSessions(courseId);
  }

  // =============================
  // SESSION CRUD OPERATIONS
  // =============================

  /// Create a new session
  Future<bool> createSession({
    required String courseId,
    required String title,
    required String description,
    required String platform,
    required DateTime date,
    required String time,
    required String duration,
    required String link,
    String? password,
  }) async {
    _setCreating(true);
    _clearError();

    try {
      // Convert platform to backend enum format
      String platformEnum;
      switch (platform.toLowerCase()) {
        case 'google meet':
          platformEnum = 'meet';
          break;
        case 'zoom':
          platformEnum = 'zoom';
          break;
        case 'teams':
          platformEnum = 'teams';
          break;
        default:
          platformEnum = 'zoom'; // Default fallback
      }

      print('Platform mapping: "$platform" -> "$platformEnum"');

      final newSession = CourseSession(
        id: '', // Will be generated by backend
        courseId: courseId,
        sessionName: title,
        sessionDescription: description,
        sessionDate: date,
        sessionTime: time,
        sessionDuration: duration,
        sessionLink: link,
        sessionPassword: password,
        sessionPlatform: platformEnum,
        createdAt: DateTime.now(),
      );

      final createdSession = await _sessionRepository.createSession(newSession);

      // Add to local list
      _sessions.add(createdSession);
      _sessions.sort((a, b) => a.sessionDate.compareTo(b.sessionDate));

      // Update stats
      await _loadSessionStats(courseId);

      notifyListeners();
      return true;
    } catch (e) {
      _setError('Failed to create session: $e');
      return false;
    } finally {
      _setCreating(false);
    }
  }

  /// Update an existing session
  Future<bool> updateSession({
    required String sessionId,
    required String courseId,
    required String title,
    required String description,
    required String platform,
    required DateTime date,
    required String time,
    required String duration,
    required String link,
    String? password,
  }) async {
    _setUpdating(true);
    _clearError();

    try {
      // Convert platform to backend enum format
      String platformEnum;
      switch (platform.toLowerCase()) {
        case 'google meet':
          platformEnum = 'meet';
          break;
        case 'zoom':
          platformEnum = 'zoom';
          break;
        case 'teams':
          platformEnum = 'teams';
          break;
        default:
          platformEnum = 'zoom'; // Default fallback
      }

      print('Update platform mapping: "$platform" -> "$platformEnum"');

      final updates = {
        'session_name': title,
        'session_description': description,
        'session_platform': platformEnum,
        'session_date': date.toIso8601String(),
        'session_time': time,
        'session_duration': duration,
        'session_link': link,
        'session_password': password,
      };

      final updatedSession = await _sessionRepository.updateSession(
        sessionId,
        updates,
      );

      // Update local list
      final index = _sessions.indexWhere((s) => s.id == sessionId);
      if (index != -1) {
        _sessions[index] = updatedSession;
        _sessions.sort((a, b) => a.sessionDate.compareTo(b.sessionDate));
      }

      // Update stats
      await _loadSessionStats(courseId);

      notifyListeners();
      return true;
    } catch (e) {
      _setError('Failed to update session: $e');
      return false;
    } finally {
      _setUpdating(false);
    }
  }

  /// Delete a session
  Future<bool> deleteSession(String sessionId, String courseId) async {
    _setDeleting(true);
    _clearError();

    try {
      print('OnlineSessionProvider: Attempting to delete session $sessionId');
      await _sessionRepository.deleteSession(sessionId);

      // Remove from local list
      _sessions.removeWhere((s) => s.id == sessionId);
      print('OnlineSessionProvider: Session removed from local list');

      // Update stats
      await _loadSessionStats(courseId);

      notifyListeners();
      print('OnlineSessionProvider: Delete operation completed successfully');
      return true;
    } catch (e) {
      final errorMessage = 'Failed to delete session: $e';
      print('OnlineSessionProvider error: $errorMessage');
      _setError(errorMessage);
      return false;
    } finally {
      _setDeleting(false);
    }
  }

  /// Get session by ID
  Future<CourseSession?> getSession(String sessionId) async {
    try {
      _currentSession = await _sessionRepository.getSessionById(sessionId);
      notifyListeners();
      return _currentSession;
    } catch (e) {
      _setError('Failed to load session: $e');
      return null;
    }
  }

  // =============================
  // UTILITY METHODS
  // =============================

  /// Clear current session
  void clearCurrentSession() {
    _currentSession = null;
    notifyListeners();
  }

  /// Clear all sessions (useful when switching courses)
  void clearSessions() {
    _sessions.clear();
    _sessionStats.clear();
    _currentSession = null;
    notifyListeners();
  }

  /// Get sessions count by status
  int getSessionsCount(String status) {
    switch (status.toLowerCase()) {
      case 'upcoming':
      case 'scheduled':
        return upcomingSessions.length;
      case 'completed':
        return completedSessions.length;
      case 'total':
      default:
        return _sessions.length;
    }
  }

  // =============================
  // PRIVATE METHODS
  // =============================

  void _setLoading(bool loading) {
    _isLoading = loading;
    if (loading) _clearError();
    notifyListeners();
  }

  void _setCreating(bool creating) {
    _isCreating = creating;
    if (creating) _clearError();
    notifyListeners();
  }

  void _setUpdating(bool updating) {
    _isUpdating = updating;
    if (updating) _clearError();
    notifyListeners();
  }

  void _setDeleting(bool deleting) {
    _isDeleting = deleting;
    if (deleting) _clearError();
    notifyListeners();
  }

  void _setError(String error) {
    _error = error;
    notifyListeners();
  }

  void _clearError() {
    _error = null;
  }
}
